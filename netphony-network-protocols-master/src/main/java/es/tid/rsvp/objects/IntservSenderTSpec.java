package es.tid.rsvp.objects;

import es.tid.rsvp.RSVPProtocolViolationException;

/*
 * 

      o    Intserv SENDER_TSPEC object: Class = 12, C-Type = 2

           The contents and encoding rules for this object are specified
           in documents prepared by the int-serv working group.

3.1. RSVP SENDER_TSPEC Object

   The RSVP SENDER_TSPEC object carries information about a data
   source's generated traffic. The required RSVP SENDER_TSPEC object
   contains a global Token_Bucket_TSpec parameter (service_number 1,
   parameter 127, as defined in [RFC 2215]). This TSpec carries traffic
   information usable by either the Guaranteed or Controlled-Load QoS
   control services.


Wroclawski                  Standards Track                    [Page 10]

RFC 2210                   RSVP with INTSERV              September 1997


        31           24 23           16 15            8 7             0
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1   | 0 (a) |    reserved           |             7 (b)             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2   |    1  (c)     |0| reserved    |             6 (d)             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3   |   127 (e)     |    0 (f)      |             5 (g)             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4   |  Token Bucket Rate [r] (32-bit IEEE floating point number)    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5   |  Token Bucket Size [b] (32-bit IEEE floating point number)    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6   |  Peak Data Rate [p] (32-bit IEEE floating point number)       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   7   |  Minimum Policed Unit [m] (32-bit integer)                    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   8   |  Maximum Packet Size [M]  (32-bit integer)                    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


     (a) - Message format version number (0)
     (b) - Overall length (7 words not including header)
     (c) - Service header, service number 1 (default/global information)
     (d) - Length of service 1 data, 6 words not including header
     (e) - Parameter ID, parameter 127 (Token_Bucket_TSpec)
     (f) - Parameter 127 flags (none set)
     (g) - Parameter 127 length, 5 words not including header


   In this TSpec, the parameters [r] and [b] are set to reflect the
   sender's view of its generated traffic. The peak rate parameter [p]
   may be set to the sender's peak traffic generation rate (if known and
   controlled), the physical interface line rate (if known), or positive
   infinity (if no better value is available).  Positive infinity is
   represented as an IEEE single-precision floating-point number with an
   exponent of all ones (255) and a sign and mantissa of all zeros.  The
   format of IEEE floating-point numbers is further summarized in [RFC
   1832].

   The minimum policed unit parameter [m] should generally be set equal
   to the size of the smallest packet generated by the application. This
   packet size includes the application data and all protocol headers at
   or above the IP level (IP, TCP, UDP, RTP, etc.). The size given does
   not include any link-level headers, because these headers will change
   as the packet crosses different portions of the internetwork.






Wroclawski                  Standards Track                    [Page 11]

RFC 2210                   RSVP with INTSERV              September 1997


   The [m] parameter is used by nodes within the network to compute the
   maximum bandwidth overhead needed to carry a flow's packets over the
   particular link-level technology, based on the ratio of [m] to the
   link-level header size. This allows the correct amount of bandwidth
   to be allocated to the flow at each point in the net.  Note that
   smaller values of this parameter lead to increased overhead
   estimates, and thus increased likelyhood of a reservation request
   being rejected by the node. In some cases, an application
   transmitting a low percentage of very small packets may therefore
   choose to set the value of [m] larger than the actual minimum
   transmitted packet size. This will increase the likelyhood of the
   reservation succeeding, at the expense of policing packets of size
   less than [m] as if they were of size [m].

   Note that the an [m] value of zero is illegal. A value of zero would
   indicate that no data or IP headers are present, and would give an
   infinite amount of link-level overhead.

   The maximum packet size parameter [M] should be set to the size of
   the largest packet the application might wish to generate, as
   described in Section 2.3.2. This value must, by definition, be equal
   to or larger than the value of [m].


 * 
 */

public class IntservSenderTSpec extends SenderTSpec{

	// FIXME: Buscar Intserv SENDER_TSPEC object en int-serv working group
	
	private int formatVersionNumber;
	
	private int overallLength;
	
	private int serviceHeader;
	
	private int lengthOfService;
	
	private int parameterID;
	
	private int parameter127Flags;
	
	private int parameter127length;
	
	private float tokenBucketRate;
	
	private float tokenBucketSize;
	
	private float peakDataRate;
	
	private long minimumPoliciedUnit;
	
	private long maximumPacketSize;
	
	
	public IntservSenderTSpec(){
		super();
		cType = 2;

		
	}
	
	public IntservSenderTSpec(byte[] bytes, int offset) throws RSVPProtocolViolationException{
		super(bytes,offset);
		decode( );
	}
	
	public IntservSenderTSpec(float tokenBucketRate, float tokenBucketSize, float peakDataRate, long minimumPoliciedUnit, long maximumPacketSize){
		super();
    	this.formatVersionNumber = 0;
    	this.overallLength = 7;
    	this.serviceHeader = 1;
    	this.lengthOfService = 6;
    	this.parameterID = 127;
    	this.parameter127Flags = 0;
    	this.parameter127length = 5;
    	
    	this.tokenBucketRate = tokenBucketRate;
    	this.tokenBucketSize = tokenBucketSize;
    	this.peakDataRate = peakDataRate;
    	this.minimumPoliciedUnit = minimumPoliciedUnit;
    	this.maximumPacketSize = maximumPacketSize;

		classNum = 12;
		cType = 2;
		
		
	}
	
	/*	
    0             1              2             3
    +-------------+-------------+-------------+-------------+
    |       Length (bytes)      |  Class-Num  |   C-Type    |
    +-------------+-------------+-------------+-------------+
    |                                                       |
    //                  (Object contents)                   //
    |                                                       |
    +-------------+-------------+-------------+-------------+	
            31           24 23           16 15            8 7             0
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1   | 0 (a) |    reserved           |             7 (b)             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2   |    1  (c)     |0| reserved    |             6 (d)             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3   |   127 (e)     |    0 (f)      |             5 (g)             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4   |  Token Bucket Rate [r] (32-bit IEEE floating point number)    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5   |  Token Bucket Size [b] (32-bit IEEE floating point number)    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6   |  Peak Data Rate [p] (32-bit IEEE floating point number)       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   7   |  Minimum Policed Unit [m] (32-bit integer)                    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   8   |  Maximum Packet Size [M]  (32-bit integer)                    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    */
	
	@Override
	public void encode() {
		length = 36;
		bytes = new byte[length];
		// TODO Auto-generated method stub
		encodeHeader();
		
		int offset = 4;
		
		this.bytes[offset] = (byte)(this.formatVersionNumber >> 4 & 0xF0);
		this.bytes[offset+1] = (byte)(0 & 0xff);
		this.bytes[offset+2] = (byte)(this.overallLength >> 8 & 0xFF);
		this.bytes[offset+3] = (byte)(this.overallLength & 0xFF);
		
		offset = offset + 4;
		
		this.bytes[offset] = (byte)(this.serviceHeader & 0xFF);
		this.bytes[offset+1] = (byte)(0 & 0xff);
		this.bytes[offset+2] = (byte)(this.lengthOfService >> 8 & 0xFF);
		this.bytes[offset+3] = (byte)(this.lengthOfService & 0xFF);
		
		offset = offset + 4;
		
		this.bytes[offset] = (byte)(this.parameterID & 0xFF);
		this.bytes[offset+1] = (byte)(this.parameter127Flags & 0xff);
		this.bytes[offset+2] = (byte)(this.parameter127length >> 8 & 0xFF);
		this.bytes[offset+3] = (byte)(this.parameter127length & 0xFF);
		
		offset = offset + 4;
		
		int tbr = Float.floatToIntBits(this.tokenBucketRate);
		
		this.bytes[offset] = (byte)(tbr >>> 24);
		this.bytes[offset+1] = (byte)(tbr >> 16 & 0xff);
		this.bytes[offset+2] = (byte)(tbr >> 8 & 0xff);
		this.bytes[offset+3] = (byte)(tbr & 0xff);
		
		offset = offset + 4;
		
		int tbs = Float.floatToIntBits(this.tokenBucketSize);
		
		this.bytes[offset] = (byte)(tbs >>> 24);
		this.bytes[offset+1] = (byte)(tbs >> 16 & 0xff);
		this.bytes[offset+2] = (byte)(tbs >> 8 & 0xff);
		this.bytes[offset+3] = (byte)(tbs & 0xff);

		offset = offset + 4;
		
		int pdr = Float.floatToIntBits(this.peakDataRate);
		
		this.bytes[offset] = (byte)(pdr >>> 24);
		this.bytes[offset+1] = (byte)(pdr >> 16 & 0xff);
		this.bytes[offset+2] = (byte)(pdr >> 8 & 0xff);
		this.bytes[offset+3] = (byte)(pdr & 0xff);
		
		offset = offset + 4;
		
		this.bytes[offset] = (byte)(this.minimumPoliciedUnit >>> 24);
		this.bytes[offset+1] = (byte)(this.minimumPoliciedUnit >> 16 & 0xff);
		this.bytes[offset+2] = (byte)(this.minimumPoliciedUnit >> 8 & 0xff);
		this.bytes[offset+3] = (byte)(this.minimumPoliciedUnit & 0xff);
		
		offset = offset + 4;
				
		this.bytes[offset] = (byte)(this.maximumPacketSize >>> 24);
		this.bytes[offset+1] = (byte)(this.maximumPacketSize >> 16 & 0xff);
		this.bytes[offset+2] = (byte)(this.maximumPacketSize >> 8 & 0xff);
		this.bytes[offset+3] = (byte)(this.maximumPacketSize & 0xff);
		
	}


	
	public void decode() {
		//FIXME: Codificar el decode si investigamos en la RFC de intserv
				
	}

	public int getFormatVersionNumber() {
		return formatVersionNumber;
	}

	public void setFormatVersionNumber(int formatVersionNumber) {
		this.formatVersionNumber = formatVersionNumber;
	}

	public int getOverallLength() {
		return overallLength;
	}

	public void setOverallLength(int overallLength) {
		this.overallLength = overallLength;
	}

	public int getServiceHeader() {
		return serviceHeader;
	}

	public void setServiceHeader(int serviceHeader) {
		this.serviceHeader = serviceHeader;
	}

	public int getLengthOfService() {
		return lengthOfService;
	}

	public void setLengthOfService(int lengthOfService) {
		this.lengthOfService = lengthOfService;
	}

	public int getParameterID() {
		return parameterID;
	}

	public void setParameterID(int parameterID) {
		this.parameterID = parameterID;
	}

	public int getParameter127Flags() {
		return parameter127Flags;
	}

	public void setParameter127Flags(int parameter127Flags) {
		this.parameter127Flags = parameter127Flags;
	}

	public int getParameter127length() {
		return parameter127length;
	}

	public void setParameter127length(int parameter127length) {
		this.parameter127length = parameter127length;
	}

	public float getTokenBucketRate() {
		return tokenBucketRate;
	}

	public void setTokenBucketRate(float tokenBucketRate) {
		this.tokenBucketRate = tokenBucketRate;
	}

	public float getTokenBucketSize() {
		return tokenBucketSize;
	}

	public void setTokenBucketSize(float tokenBucketSize) {
		this.tokenBucketSize = tokenBucketSize;
	}

	public float getPeakDataRate() {
		return peakDataRate;
	}

	public void setPeakDataRate(float peakDataRate) {
		this.peakDataRate = peakDataRate;
	}

	public long getMinimumPoliciedUnit() {
		return minimumPoliciedUnit;
	}

	public void setMinimumPoliciedUnit(long minimumPoliciedUnit) {
		this.minimumPoliciedUnit = minimumPoliciedUnit;
	}

	public long getMaximumPacketSize() {
		return maximumPacketSize;
	}

	public void setMaximumPacketSize(long maximumPacketSize) {
		this.maximumPacketSize = maximumPacketSize;
	}

	
	

}
