package es.tid.pce.pcep.objects;

import es.tid.pce.pcep.objects.tlvs.PCEPTLV;
import es.tid.pce.pcep.objects.tlvs.PathSetupTLV;
import es.tid.pce.pcep.objects.tlvs.SymbolicPathNameTLV;
import es.tid.protocol.commons.ByteHandler;

/**
 * SRP Object.
 * 
 * The SRP (Stateful PCE Request Parameters) object MUST be carried
 *  within PCUpd messages and MAY be carried within PCRpt and PCErr
 *  messages.  The SRP object is used to correlate between update
 *  requests sent by the PCE and the error reports and state reports sent
 *  by the PCC.
 * 
 * @see <a href="https://tools.ietf.org/html/rfc8231#page-33">RFC 8231 page 33</a>
 * @see <a href="https://www.iana.org/assignments/pcep/pcep.xhtml#srp-object-flag-field">SRP Object flag fields</a>  
 * @author jaume
 * @author Oscar Gonzalez de Dios
 */

public class SRP extends PCEPObject
{

	/*
	 * 
   The SRP (Stateful PCE Request Parameters) object MUST be carried
   within PCUpd messages and MAY be carried within PCRpt and PCErr
   messages.  The SRP object is used to correlate between update
   requests sent by the PCE and the error reports and state reports sent
   by the PCC.

   SRP Object-Class is 33.

   SRP Object-Type is 1.

   The format of the SRP object body is shown in Figure 10:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Flags                            |C|R|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        SRP-ID-number                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                      Optional TLVs                          //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                     The SRP Object Format (updated with hrfc8281)

   The SRP object body has a variable length and may contain additional
   TLVs.

   Flags (32 bits): 
    R (LSP-REMOVE -- 1 bit):  If set to 0, it indicates a request to
      create an LSP.  If set to 1, it indicates a request to remove an
      LSP.

   SRP-ID-number (32 bits): The SRP-ID-number value in the scope of the
   current PCEP session uniquely identifies the operation that the PCE
   has requested the PCC to perform on a given LSP.  The SRP-ID-number
   is incremented each time a new request is sent to the PCC, and it may
   wrap around.

   The values 0x00000000 and 0xFFFFFFFF are reserved.

   Optional TLVs MAY be included within the SRP object body.  The
   specification of such TLVs is outside the scope of this document.

   Every request to update an LSP receives a new SRP-ID-number.  This
   number is unique per PCEP session and is incremented each time an
   operation is requested from the PCE.  Thus, for a given LSP, there
   may be more than one SRP-ID-number unacknowledged at a given time.
   The value of the SRP-ID-number is echoed back by the PCC in PCErr and
   PCRpt messages to allow for correlation between requests made by the
   PCE and errors or state reports generated by the PCC.  If the error
   or report was not a result of a PCE operation (for example, in the
   case of a link down event), the reserved value of 0x00000000 is used
   for the SRP-ID-number.  The absence of the SRP object is equivalent
   to an SRP object with the reserved value of 0x00000000.  An
   SRP-ID-number is considered unacknowledged and cannot be reused until
   a PCErr or PCRpt arrives with an SRP-ID-number equal or higher for
   the same LSP.  In case of SRP-ID-number wrapping, the last
   SRP-ID-number before the wrapping MUST be explicitly acknowledged, to
   avoid a situation where SRP-ID-numbers remain unacknowledged after
   the wrap.  This means that the PCC may need to issue two PCUpd
   messages on detecting a wrap.
	 */
	
	/*
	 * Private Fields (accessible via getters & setters) 
	 */
	
	/*
	 * Flags 
	 * 0-29	Unassigned	
     * 30	LSP Control Request	[RFC8741]
     * 31	LSP-Remove	[RFC8281]
	 */
	
	/** 
	 * LSP-Remove	[RFC8281]
	 * R (LSP-REMOVE -- 1 bit): If set to 0, it indicates a request to
     * create an LSP.  If set to 1, it indicates a request to remove an
     * LSP.
	 */
	private boolean rFlag;

	/**
	 * LSP Control Request	[RFC8741]
	 * C Flag In a PCUpd message, a PCE sets the C
     * flag to 1 to indicate that it wishes to gain control of LSPs. 
	 */
	private boolean cFlag;
	
	/* 
	 * TLVs
	 */

	private SymbolicPathNameTLV symPathName;

	private PathSetupTLV pathSetupTLV;

	/*
	 * Fields
	 */
	
	private long SRP_ID_number;
	
	public SRP()
	{
		super();
		this.setObjectClass(ObjectParameters.PCEP_OBJECT_CLASS_SRP);
		this.setOT(ObjectParameters.PCEP_OBJECT_TYPE_SRP);
	}

	public SRP(byte []bytes, int offset)throws MalformedPCEPObjectException 
	{
		super(bytes, offset);
		decode();
	}

	public void encode() 
	{
		ObjectLength = 4 + 4 + 4;
		if (symPathName!=null)
		{
			symPathName.encode();
			ObjectLength=ObjectLength+symPathName.getTotalTLVLength();
		}

		if (pathSetupTLV!=null){
			try {
				pathSetupTLV.encode();
				this.ObjectLength+=pathSetupTLV.getTotalTLVLength();	

			}catch (Exception e){
				log.warn(e.getMessage());
			}

		}
		object_bytes = new byte[ObjectLength];
		encode_header();		
		int offset = 4;
		offset += 3;
		ByteHandler.BoolToBuffer(7 + offset*8, rFlag,object_bytes);

		offset += 1;
		//FIXME
		ByteHandler.IntToBuffer(0,offset*8, 32,(int)SRP_ID_number,this.object_bytes);

		offset += 4;

		if (symPathName != null)
		{
			System.arraycopy(symPathName.getTlv_bytes(),0,this.object_bytes,offset,symPathName.getTotalTLVLength());
			offset=offset+symPathName.getTotalTLVLength();
		}

		if (pathSetupTLV!=null){
			System.arraycopy(pathSetupTLV.getTlv_bytes(), 0,this.object_bytes, offset, pathSetupTLV.getTotalTLVLength());
			offset += pathSetupTLV.getTotalTLVLength();
		}

	}

	@Override
	public void decode() throws MalformedPCEPObjectException 
	{

		if (ObjectLength<12){
			throw new MalformedPCEPObjectException();
		}
		
		cFlag = (ByteHandler.easyCopy(6,6,object_bytes[7]) == 1) ? true : false ;
		rFlag = (ByteHandler.easyCopy(7,7,object_bytes[7]) == 1) ? true : false ;

		SRP_ID_number = ByteHandler.easyCopy(0,31,object_bytes[8],object_bytes[9],object_bytes[10],object_bytes[11]);

		boolean fin;
		int offset = 12;

		if (ObjectLength==12){
			fin=true;
		}else {
			fin = false;
		}

		while (!fin) {
			int tlvtype=PCEPTLV.getType(this.getObject_bytes(), offset);
			int tlvlength=PCEPTLV.getTotalTLVLength(this.getObject_bytes(), offset);

			switch (tlvtype){
				case ObjectParameters.PCEP_TLV_TYPE_SYMBOLIC_PATH_NAME:
					symPathName=new SymbolicPathNameTLV(this.getObject_bytes(), offset);
					break;		
				case ObjectParameters.PCEP_TLV_PATH_SETUP:
					pathSetupTLV=new PathSetupTLV(this.getObject_bytes(), offset);				
					break;								
				default:
					log.warn("Unknown or unexpected TLV found");
					break;
			}

			offset=offset+tlvlength;
			if (offset>=ObjectLength){
				fin=true;
			}
		}		
	}

	public long getSRP_ID_number() 
	{
		return SRP_ID_number;
	}

	public void setSRP_ID_number(long sRP_ID_number) 
	{
		SRP_ID_number = sRP_ID_number;
	}

	public SymbolicPathNameTLV getSymPathName() 
	{
		return symPathName;
	}

	public void setSymPathName(SymbolicPathNameTLV symPathName) 
	{
		this.symPathName = symPathName;
	}

	public boolean isRFlag() 
	{
		return rFlag;
	}

	public void setRFlag(boolean rFlag) 
	{
		this.rFlag = rFlag;
	}

	public PathSetupTLV getPathSetupTLV() {
		return pathSetupTLV;
	}

	public void setPathSetupTLV(PathSetupTLV pathSetupTLV) {
		this.pathSetupTLV = pathSetupTLV;
	}
	

	public boolean isCFlag() {
		return cFlag;
	}

	public void setCFlag(boolean cFlag) {
		this.cFlag = cFlag;
	}

	public String toString() {
		StringBuffer sb=new StringBuffer(100);
		sb.append("<SRP id = ");
		sb.append(SRP_ID_number);	
		if (symPathName!=null){
			sb.append(symPathName.toString());
		}
		sb.append(">");
		return sb.toString();	
	}

}